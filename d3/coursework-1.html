<!DOCTYPE html>

<style>

body {
  text-align: center;
}

svg {
  margin-top: 32px;
  border: 1px solid #aaa;
}

.person rect {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1px;
}

.person {
  font: 14px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>

<!-- Add a svg area, empty -->
<svg id='dataviz_area' height=800 width=1000></svg>

<!-- Load d3.js -->
<script src='https://d3js.org/d3.v4.js'></script>

<script>

var screen_height = 800
var screen_width = 1000

var svg = d3.select('#dataviz_area')

var box_width = 110;
var box_height = 40;
var text_x_offset = 10; 
var text_y_offset = 25;

// Define a variable to keep track of the rectangles' positions
var positions = {};

var tickmarks = {};

// Define drag behavior
var drag = d3.drag()
  .on("start", dragstarted)
  .on("drag", dragged0);

function dragstarted(d) {
  d3.select(this)
    .raise()
    .classed("active", true);
}

function dragged4(d) {
  // Calculate the new x position
  var newX = Math.round((d3.event.x - 5) / 125) * 125 + 5; // Snap to the nearest tick mark

  // Check if the rectangle is close enough to the tick mark to snap
  if (Math.abs(d3.event.x - newX) > 50) { // Adjust the threshold distance as needed
    newX = d3.event.x; // If not, keep the rectangle at its current x position
  }

  // Calculate the new y position
  var newY = svg.attr("height") - 50; // Start at the bottom
  if (positions[newX]) { // If there's already a rectangle at this x position...
    newY -= positions[newX] * (box_height + 5); // ...stack the new rectangle on top
  } else {
    positions[newX] = 0; // Initialize the stack
  }
  positions[newX]++; // Increase the stack count

  // Ensure newY never goes above a certain value
  newY = Math.max(newY, 0);

  // Move the rectangle
  d3.select(this)
    .select("rect")
    .attr("x", newX)
    .attr("y", newY);

  // Move the text
  d3.select(this)
    .select("text")
    .attr("x", newX + text_x_offset)
    .attr("y", newY + text_y_offset);
}

function dragged3(d) {
  // Calculate the new x position
  var newX = Math.round((d3.event.x - 5) / 125) * 125 + 5; // Snap to the nearest tick mark

  // Calculate the new y position
  var newY = svg.attr("height") - 50; // Start at the bottom
  if (positions[newX]) { // If there's already a rectangle at this x position...
    newY -= positions[newX] * (box_height + 5); // ...stack the new rectangle on top
  } else {
    positions[newX] = 0; // Initialize the stack
  }
  positions[newX]++; // Increase the stack count

  // Ensure newY never goes below a certain value
  newY = Math.max(newY, 0);

  // Move the rectangle
  d3.select(this)
    .select("rect")
    .attr("x", newX)
    .attr("y", newY);

  // Move the text
  d3.select(this)
    .select("text")
    .attr("x", newX + text_x_offset)
    .attr("y", newY + text_y_offset);
}

function dragged2(d) {
  // Calculate the new x position
  var newX = Math.round((d3.event.x - 5) / 125) * 125 + 5; // Snap to the nearest tick mark

  // Calculate the new y position
  var newY = svg.attr("height") - 50; // Start at the bottom
  if (positions[newX]) { // If there's already a rectangle at this x position...
    newY -= positions[newX] * (box_height + 5); // ...stack the new rectangle on top
  } else {
    positions[newX] = 0; // Initialize the stack
  }
  positions[newX]++; // Increase the stack count

  // Ensure newY never goes below a certain value
  newY = Math.max(newY, box_height);

  // Move the rectangle
  d3.select(this)
    .select("rect")
    .attr("x", newX)
    .attr("y", newY);

  // Move the text
  d3.select(this)
    .select("text")
    .attr("x", newX + text_x_offset)
    .attr("y", newY + text_y_offset);
}

function dragged1(d) {
  // Calculate the new x position
  var newX = Math.round((d3.event.x - 5) / 125) * 125 + 5; // Snap to the nearest tick mark

  // Calculate the new y position
  var newY = svg.attr("height") - 50; // Start at the bottom
  if (positions[newX]) { // If there's already a rectangle at this x position...
    newY -= positions[newX] * (box_height + 5); // ...stack the new rectangle on top
  } else {
    positions[newX] = 0; // Initialize the stack
  }
  positions[newX]++; // Increase the stack count

  // Move the rectangle
  d3.select(this)
    .select("rect")
    .attr("x", newX)
    .attr("y", newY);

  // Move the text
  d3.select(this)
    .select("text")
    .attr("x", newX + text_x_offset)
    .attr("y", newY + text_y_offset);
}

function dragged0(d) {
  // move the rectangle
  d3.select(this)
    .select("rect")
    .attr("x", d3.event.x)
    .attr("y", d3.event.y);

  // move the text
  d3.select(this)
    .select("text")
    .attr("x", d3.event.x + text_x_offset)
    .attr("y", d3.event.y + text_y_offset);
}

// TIMELINE

// Define the scale for your timeline
var xScale = d3.scaleLinear()
  .domain([1, 9]) // input range
  .range([5, 995]); // output range

//// Define the axis for your timeline
//var xAxis = d3.axisBottom(xScale)
//  .tickValues([1, 2, 3, 4, 5, 6, 7, 8, 9]) // specify explicitly where you want the ticks
//  .tickFormat(d3.format("d")); // format the ticks as integers

// Define the axis for your timeline
var xAxis = d3.axisBottom(xScale)
  .tickValues([1, 2, 3, 4, 5, 6, 7, 8, 9]) // specify explicitly where you want the ticks
  .tickFormat(function(d) { 
    if (d <= 8) {
      return 'Period ' + d; // format the ticks as 'Period 1', 'Period 2', etc.
    } else {
      return ''; // don't return a label for the 9th tick
    }
  });


// Append the axis to your SVG
svg.append("g")
  .attr("transform", "translate(0," + (svg.attr("height") - 50) + ")") // position the axis at the bottom of the SVG
  .call(xAxis);

// After defining and appending your axis...

// Get the tick marks
var ticks = d3.selectAll(".tick");

// For each tick mark, append a line that extends upwards
ticks.each(function(d, i) {
  svg.append("line")
    .attr("x1", xScale(d))
    .attr("y1", svg.attr("height") - 50)
    .attr("x2", xScale(d))
    .attr("y2", svg.attr("height") - 325) // 250 units above the axis
    .style("stroke", "#aaa")
    .style("stroke-width", 3);
});

//// Select the tick labels and adjust their x position
//d3.selectAll(".tick text")
//  .attr("x", function(d) { return xScale(d) + 20; }); // Offset by 20 units


// Function to create a rectangle and its associated text
function my_rectangle(x, y, name, color, textcolor='white') {
  var g = svg.append("g")
    .attr("transform", "translate(0,0)")
    .call(drag);
  g.append('rect')
    .attr('x', x)
    .attr('y', y)
    .attr('width', box_width)
    .attr('height', box_height)
    .style('fill', color);
  g.append('text')
    .attr('x', x + text_x_offset)
    .attr('y', y + text_y_offset)
    .text(name)
    .attr('fill', textcolor)
    .style("font-size", "12px")
    .style("font-family", "Arial")
    .style("font-weight", "bold");
}

//// Define a map for groups
//var groups = {};
//
//// Modify the my_rectangle function
//function my_rectangle_g(x, y, name, color, group) {
//  // If the group doesn't exist, create a new one
//  if (!groups[group]) {
//    groups[group] = svg.append("g")
//      .attr("transform", "translate(0,0)")
//      .call(drag);
//  }
//
//  var g = groups[group];
//  
//  g.append('rect')
//    .attr('x', x)
//    .attr('y', y)
//    .attr('width', box_width)
//    .attr('height', box_height)
//    .style('fill', color);
//  
//  g.append('text')
//    .attr('x', x + text_x_offset)
//    .attr('y', y + text_y_offset)
//    .text(name)
//    .attr('fill', 'white')
//    .style("font-size", "12px")
//    .style("font-family", "Arial")
//    .style("font-weight", "bold");
//}

// Use the function to create rectangles

//my_rectangle_g(10, 100, 'ACCT 220 (3)', 'blue', 'ACCT');
//my_rectangle_g(10, 150, 'ACCT 221 (3)', 'blue', 'ACCT');

var y_gap = 2;

// Create horizontal bins for course rectangles

var bin = [12];
bin.push(bin[0] + 13 + box_width);
bin.push(bin[1] + 14 + box_width);
bin.push(bin[2] + 14 + box_width);
bin.push(bin[3] + 14 + box_width);
bin.push(bin[4] + 14 + box_width);
bin.push(bin[5] + 14 + box_width);
bin.push(bin[6] + 14 + box_width);

var box_space = box_height + y_gap + 2;
var x_axis_height = screen_height - 54;

var row = [x_axis_height - 1*box_space]
row.push(x_axis_height - 2*box_space)
row.push(x_axis_height - 3*box_space)
row.push(x_axis_height - 4*box_space)
row.push(x_axis_height - 5*box_space)
row.push(x_axis_height - 6*box_space)
row.push(x_axis_height - 7*box_space)


//// Function to create a rectangle and its associated text
//function my_rect(tk, ht, name, color, textcolor='white') {
//  var y = x_axis_height - ht*box_space;
//  var g = svg.append("g")
//    .attr("transform", "translate(0,0)")
//    .call(drag);
//  g.append('rect')
//    .attr('x', x)
//    .attr('y', y)
//    .attr('width', box_width)
//    .attr('height', box_height)
//    .style('fill', color);
//  g.append('text')
//    .attr('x', x + text_x_offset)
//    .attr('y', y + text_y_offset)
//    .text(name)
//    .attr('fill', textcolor)
//    .style("font-size", "12px")
//    .style("font-family", "Arial")
//    .style("font-weight", "bold");
//}

//my_rectangle(tick_2, 1*box_space, 'BMGT 495 (3)', 'blue');

my_rectangle(bin[0], row[5], 'PACE 111B (3)', 'green');
my_rectangle(bin[0], row[4], 'LIBS 150 (1)', 'green');
my_rectangle(bin[0], row[3], 'WRTG 111 (3)', 'green');
my_rectangle(bin[0], row[2], 'WRTG 112 (3)', 'green');
my_rectangle(bin[0], row[1], 'NUTR 100 (3)', 'green');
my_rectangle(bin[0], row[0], 'BMGT 110 (3)', 'blue');

my_rectangle(bin[1], row[5], 'SPCH 100 (3)', 'green');
my_rectangle(bin[1], row[4], 'STAT 200 (3)', 'red');
my_rectangle(bin[1], row[3], 'IFSM 300 (3)', 'red');
my_rectangle(bin[1], row[2], 'ACCT 220 (3)', 'blue');
my_rectangle(bin[1], row[1], 'HUMN 100 (3)', 'green');
my_rectangle(bin[1], row[0], 'BIOL 103 (4)', 'green');

my_rectangle(bin[2], row[5], 'ECON 201 (3)', 'red');
my_rectangle(bin[2], row[4], 'ARTH 334 (3)', 'green');
my_rectangle(bin[2], row[3], 'ELECTIVE 1 (3)', 'yellow', 'black');
my_rectangle(bin[2], row[2], 'ECON 203 (3)', 'red');
my_rectangle(bin[2], row[1], 'ACCT 221 (3)', 'blue');
my_rectangle(bin[2], row[0], 'ELECTIVE 2 (3)', 'yellow', 'black');

my_rectangle(bin[3], row[5], 'BMGT 364 (3)', 'blue');
my_rectangle(bin[3], row[4], 'ELECTIVE 3 (3)', 'yellow', 'black');
my_rectangle(bin[3], row[3], 'BMGT 365 (3)', 'blue');
my_rectangle(bin[3], row[2], 'ELECTIVE 4 (3)', 'yellow', 'black');
my_rectangle(bin[3], row[1], 'MRKT 310 (3)', 'blue');
my_rectangle(bin[3], row[0], 'WRTG 394 (3)', 'green');

my_rectangle(bin[4], row[5], 'ELECTIVE 5 (3)', 'yellow', 'black');
my_rectangle(bin[4], row[4], 'BMGT 380 (3)', 'blue');
my_rectangle(bin[4], row[3], 'ELECTIVE 6 (3)', 'yellow', 'black');
my_rectangle(bin[4], row[2], 'ELECTIVE 7 (3)', 'yellow', 'black');
my_rectangle(bin[4], row[1], 'HRMN 300 (3)', 'blue');
my_rectangle(bin[4], row[0], 'ELECTIVE 8 (3)', 'yellow', 'black');

my_rectangle(bin[5], row[5], 'ELECTIVE 9 (3)', 'yellow', 'black');
my_rectangle(bin[5], row[4], 'FINC 330 (3)', 'blue');
my_rectangle(bin[5], row[3], 'ELECTIVE 10 (3)', 'yellow', 'black');
my_rectangle(bin[5], row[2], 'ELECTIVE 11 (3)', 'yellow', 'black');
my_rectangle(bin[5], row[1], 'BMGT 496 (3)', 'blue');
my_rectangle(bin[5], row[0], 'ELECTIVE 12 (3)', 'yellow', 'black');

my_rectangle(bin[6], row[5], 'ELECTIVE 13 (3)', 'yellow', 'black');
my_rectangle(bin[6], row[4], 'ELECTIVE 14 (3)', 'yellow', 'black');
my_rectangle(bin[6], row[3], 'ELECTIVE 15 (3)', 'yellow', 'black');
my_rectangle(bin[6], row[2], 'BMGT 495 (3)', 'blue');
my_rectangle(bin[6], row[1], 'ELECTIVE 16 (1)', 'yellow', 'black');

</script>
