graph TD
    %% Styles
    classDef function fill:#f9f,stroke:#333,stroke-width:2px;
    classDef condition fill:#ffd,stroke:#333,stroke-width:2px;
    
    %% Simple parameter passing
    A[process_data]:::function -->|data_type: str| B[validate_data]:::function
    B -->|validated_data: dict| C[store_data]:::function
    
    %% Multiple parameters
    D[calculate_metrics]:::function -->|data: pd.DataFrame, metrics: List[str]| E[generate_report]:::function
    
    %% Conditional branching
    F[check_user_status]:::function --> G{Is Premium?}:::condition
    G -->|Yes| H[serve_premium_content]:::function
    G -->|No| I[serve_basic_content]:::function
    
    %% Complex conditions
    J[process_order]:::function --> K{Order total}:::condition
    K -->|total < 50| L[apply_small_order_fee]:::function
    K -->|50 <= total < 100| M[standard_processing]:::function
    K -->|total >= 100| N[apply_discount]:::function
    
    %% Function with multiple outputs
    O[analyze_text]:::function --> |sentiment_score: float| P[categorize_sentiment]:::function
    O --> |word_count: int| Q[check_length]:::function
    O --> |key_phrases: List[str]| R[extract_topics]:::function
    
    %% Looping process
    S[start_processing]:::function --> T[process_batch]:::function
    T -->|processed_items: List| U{More items?}:::condition
    U -->|Yes| T
    U -->|No| V[finalize_processing]:::function
    
    %% Subgraph for grouped functionality
    subgraph User Authentication
        W[verify_credentials]:::function --> X{Valid?}:::condition
        X -->|Yes| Y[grant_access]:::function
        X -->|No| Z[deny_access]:::function
    end
    
    %% Legend
    subgraph Legend
        L1[Function]:::function
        L2{Condition}:::condition
        L3[Function A] -->|parameter: type| L4[Function B]
    end

%% Certainly! I'm glad you're considering both high-level and detailed views of your architecture. That's a great approach to maintain clarity while still capturing important details. Let's explore some more advanced examples of parameter indicators and complex conditions in Mermaid diagrams.



```mermaid
graph TD
    %% Styles
    classDef function fill:#f9f,stroke:#333,stroke-width:2px;
    classDef condition fill:#ffd,stroke:#333,stroke-width:2px;
    
    %% Simple parameter passing
    A[process_data]:::function -->|data_type: str| B[validate_data]:::function
    B -->|validated_data: dict| C[store_data]:::function
    
    %% Multiple parameters
    D[calculate_metrics]:::function -->|data: pd.DataFrame, metrics: List[str]| E[generate_report]:::function
    
    %% Conditional branching
    F[check_user_status]:::function --> G{Is Premium?}:::condition
    G -->|Yes| H[serve_premium_content]:::function
    G -->|No| I[serve_basic_content]:::function
    
    %% Complex conditions
    J[process_order]:::function --> K{Order total}:::condition
    K -->|total < 50| L[apply_small_order_fee]:::function
    K -->|50 <= total < 100| M[standard_processing]:::function
    K -->|total >= 100| N[apply_discount]:::function
    
    %% Function with multiple outputs
    O[analyze_text]:::function --> |sentiment_score: float| P[categorize_sentiment]:::function
    O --> |word_count: int| Q[check_length]:::function
    O --> |key_phrases: List[str]| R[extract_topics]:::function
    
    %% Looping process
    S[start_processing]:::function --> T[process_batch]:::function
    T -->|processed_items: List| U{More items?}:::condition
    U -->|Yes| T
    U -->|No| V[finalize_processing]:::function
    
    %% Subgraph for grouped functionality
    subgraph User Authentication
        W[verify_credentials]:::function --> X{Valid?}:::condition
        X -->|Yes| Y[grant_access]:::function
        X -->|No| Z[deny_access]:::function
    end
    
    %% Legend
    subgraph Legend
        L1[Function]:::function
        L2{Condition}:::condition
        L3[Function A] -->|parameter: type| L4[Function B]
    end


%% This diagram demonstrates several advanced techniques:
%% 
%% 1. **Simple parameter passing**: Showing data types (e.g., `data_type: str`).
%% 
%% 2. **Multiple parameters**: Passing multiple parameters to a function (e.g., `data: pd.DataFrame, metrics: List[str]`).
%% 
%% 3. **Conditional branching**: Using diamond shapes for conditions and branching based on the outcome.
%% 
%% 4. **Complex conditions**: Showing multiple branches based on numerical conditions.
%% 
%% 5. **Functions with multiple outputs**: Demonstrating how a single function can pass different outputs to multiple other functions.
%% 
%% 6. **Looping processes**: Illustrating a loop in the workflow with a condition leading back to a previous step.
%% 
%% 7. **Subgraphs**: Grouping related functionality (like User Authentication) into a subgraph for better organization.
%% 
%% Here are some tips for implementing these in your diagrams:
%% 
%% 1. Use consistent naming conventions for your functions and parameters.
%% 2. For complex conditions, you can use line breaks in the condition text for better readability, like this:
%%    ```
%%    K{Order total<br/>and user type}
%%    ```
%% 3. When showing loops, make sure the arrow directions clearly indicate the flow.
%% 4. Use subgraphs to group related functionality, especially in larger diagrams.
%% 
%% For your "zoomed out" views, you might want to focus on high-level processes and major components, using subgraphs to represent complex subsystems. For "zoomed in" views, you can dive into the details of a specific subgraph or process, showing more parameters and conditions.
%% 
%% Remember, the key is to balance detail with clarity. Even in a detailed view, try to focus on the most important parameters and conditions that affect the program flow.
%% 
%% Would you like me to elaborate on any of these techniques or show you how to apply them to a specific part of your codebase?